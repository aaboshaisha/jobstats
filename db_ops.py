"""Database operations for the app including building the database from schema and various analytical queries of the data."""

# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/db_ops.ipynb.

# %% auto 0
__all__ = ['sqls', 'get_project_root', 'get_connection', 'get_db_tables', 'init_db', 'destroy_db', 'execute_query',
           'build_locations_having_clause', 'skills_for_job', 'get_job_insights', 'top_jobs_by_location',
           'jobs_above_salary', 'jobs_above_salary_by_industry', 'jobs_in_demand_by_time', 'top_skills_by_industry',
           'top_skills_by_category', 'skill_salary_range', 'skills_ranked_by_salary', 'missing_skills',
           'companies_hiring_for_skill']

# %% nbs/db_ops.ipynb 2
import sqlite3
from typing import Optional

# %% nbs/db_ops.ipynb 3
from pathlib import Path
import os

# %% nbs/db_ops.ipynb 4
sqls = ["""
create table if not exists skills(
    id integer primary key,
    name text not null,
    category text
)"""
, 
"""
create table if not exists companies(
    id integer primary key,
    name text not null
)"""
,
"""
create table if not exists locations(
    id integer primary key,
    city text,
    country text,
    country_code text(2),
    unique(city, country, country_code)
)"""
,
"""
create table if not exists industries(
    id integer primary key,
    name text not null
);"""
,
"""
create table if not exists jobs(
    id integer primary key,
    title text not null,
    company_id integer not null,
    location_id integer not null,
    location_type text check (location_type in("remote", "onsite", "hybrid", "unknown")),
    industry_id integer not null,
    education text,
    years_of_experience int,
    salary_min int,
    salary_max int,
    posted_date text,
    deadline text,
    source TEXT,           -- 'remoteok', 'linkedin', etc.
    source_id TEXT,        -- their unique ID if available  
    job_hash TEXT,      -- generated hash as backup
    unique(source, source_id),  -- No duplicate source IDs within the same source
    unique(source, job_hash), -- No duplicate hashes within the same source butallows the same ID/hash across different sources
    constraint fk_company_id foreign key (company_id) references companies(id), 
    constraint fk_location_id foreign key (location_id) references locations(id),
    constraint fk_industry_id foreign key (industry_id) references industries(id)
)"""
,
"""
create table if not exists job_skills(
    job_id integer not null,
    skill_id integer not null,
    importance integer default 0,
    unique(job_id, skill_id),
    constraint fk_job_id foreign key (job_id) references jobs(id),
    constraint fk_skill_id foreign key(skill_id) references skills(id)
)"""]

# %% nbs/db_ops.ipynb 5
def get_project_root()-> Path:
    'Returns the absolute path to the project root directory.'
    if '__file__' in locals() or '__file__' in globals(): # running a .py script
        return Path(__file__).resolve().parent
    else: # in nbs, go one level up
        return Path(os.getcwd()).parent.resolve()

# %% nbs/db_ops.ipynb 6
def get_connection(db_filename='jobs.db'):
    "Returns connection and cursor to database"
    project_root = get_project_root()
    db_path = Path(project_root) / db_filename
    conn = sqlite3.connect(db_path)
    cursor = conn.cursor()
    return conn, cursor

# %% nbs/db_ops.ipynb 7
def get_db_tables():
    conn, cursor = get_connection()
    cursor.execute('select name from sqlite_master where type="table" and name not like "%sqlite_%";')
    return conn, cursor, cursor.fetchall() # cursor, all tables

# %% nbs/db_ops.ipynb 8
def init_db(sqls):
    "Check if db exists. Build it if not"
    conn, cursor, tables = get_db_tables()
    if not tables:
        for sql in sqls:
            cursor.execute(sql)
        conn.commit()
    return conn, cursor

# %% nbs/db_ops.ipynb 9
def destroy_db():
    conn, cursor, rows = get_db_tables()
    for table in [row[0] for row in rows]:
        cursor.execute(f'drop table if exists {table};')
    conn.commit()
    conn.close()

# %% nbs/db_ops.ipynb 11
def execute_query(sql: str, params: tuple = (), print_results: bool = False) -> list[tuple] | int:
    conn, cursor = get_connection()
    try:
        cursor.execute(sql, params)
        
        # For INSERT statements, return the lastrowid
        if sql.strip().upper().startswith('INSERT'):
            conn.commit()  # Also need to commit for INSERT
            return cursor.lastrowid
        
        # For SELECT statements, return the rows
        rows = cursor.fetchall()
        if print_results:
            for row in rows:
                print(row)
        return rows
    except Exception as e:
        print(f'`execute_query` error {e}')
        conn.close()


# %% nbs/db_ops.ipynb 14
def build_locations_having_clause(country: str, city: Optional[str] = None) -> tuple[str, list]:
    having_clause, having_params = '', []
    if country:
        having_clause = " having lower(locations.country) = lower(?) "
        having_params.append(country)
    if city:
        having_clause += " and lower(locations.city) = lower(?) "
        having_params.append(city)
    return having_clause, having_params

# %% nbs/db_ops.ipynb 15
def skills_for_job(job_keywords: list[str], country: Optional[str] = None, city:Optional[str] = None, top_k: Optional[int] = 5) -> list[tuple]:
    where_clause = 'and'.join([" lower(jobs.title) like ? " for _ in job_keywords])
    where_params = [f'%{kw}%' for kw in job_keywords]

    having_clause, having_params = build_locations_having_clause(country, city)

    sql = """
    select skills.name, count(*) as count
    from jobs 
    join job_skills on jobs.id = job_skills.job_id
    join skills on job_skills.skill_id = skills.id
    join locations on jobs.location_id = locations.id\n"""
    sql += " where" + where_clause
    sql += " group by skills.name\n"
    if having_clause: sql += having_clause
    sql += " order by count desc "
    sql += " limit ?;"
    
    return execute_query(sql, tuple(where_params + having_params + [top_k]))
    

# %% nbs/db_ops.ipynb 18
def skills_for_job(job_keywords: list[str], country: Optional[str] = None, city:Optional[str] = None, top_k: Optional[int] = 5) -> list[tuple]:
    where_clause = 'and'.join([" lower(jobs.title) like ? " for _ in job_keywords])
    where_params = [f'%{kw}%' for kw in job_keywords]

    having_clause, having_params = build_locations_having_clause(country, city)

    sql = """
    select skills.name, count(*) as count
    from jobs 
    join job_skills on jobs.id = job_skills.job_id
    join skills on job_skills.skill_id = skills.id
    join locations on jobs.location_id = locations.id\n"""
    sql += " where" + where_clause
    sql += " group by skills.name\n"
    if having_clause: sql += having_clause
    sql += " order by count desc "
    sql += " limit ?;"
    
    return execute_query(sql, tuple(where_params + having_params + [top_k]))
    

# %% nbs/db_ops.ipynb 19
def get_job_insights(kws: list[str]):
    "Main page insights: location, experience and salary"
    like_params = [f'%{kw}%' for kw in kws]
    like_clause = ' and '.join(' lower(jobs.title) like ? ' for _ in kws)
    
    sql = f"""
    select location_type, years_of_experience, salary_min, salary_max 
    from jobs where
    """
    sql += like_clause + ';'
    
    return execute_query(sql, like_params)

# %% nbs/db_ops.ipynb 21
def top_jobs_by_location(country: str, city: Optional[str]=None) -> list[tuple]:
    having_clause, having_params = build_locations_having_clause(country, city)
    
    sql = """
    select title, count(*) as job_count 
    from jobs join locations on jobs.location_id = locations.id
    group by locations.id, title"""
    sql += having_clause
    sql += " order by job_count desc;"
    return execute_query(sql, having_params)

# %% nbs/db_ops.ipynb 24
def jobs_above_salary(salary_min: int, country: str, city:Optional[str]=None) -> list[tuple]:
    sql = """
    select distinct title
    from jobs join locations on jobs.location_id = locations.id
    where jobs.salary_min >=?"""
    params = [salary_min]
    if country:
        sql += ' and lower(locations.country) = lower(?)'
        params.append(country)
    if city:
        sql += ' and lower(locations.city) = lower(?)'
        params.append(city)

    return execute_query(sql, tuple(params))
        

# %% nbs/db_ops.ipynb 26
def jobs_above_salary_by_industry(salary_min:int, industry_id: int) -> list[tuple]:
    sql = """select distinct title from jobs where industry_id = ? and salary_min >= ?;"""
    return execute_query(sql, (industry_id, salary_min, ))

# %% nbs/db_ops.ipynb 28
def jobs_in_demand_by_time(start_date, interval, country: Optional[str]=None, city:Optional[str]=None):
    sql = """
    select jobs.title, count(*) as job_count 
    from jobs join locations on jobs.location_id = locations.id
    where jobs.posted_date >= date(?, ?)
    group by jobs.title
    """
    
    having_clause, having_params = build_locations_having_clause(country, city)
    sql += having_clause
    sql += " order by job_count desc;"
    params = [start_date, interval] + having_params
    
    return execute_query(sql, tuple(params))

# %% nbs/db_ops.ipynb 31
def top_skills_by_industry(industry_id: int) -> list[tuple]:
    sql = """
    select skills.name, count(*) as frequency 
    from jobs join job_skills
    on jobs.id = job_skills.job_id
    join skills on job_skills.skill_id = skills.id
    where industry_id = ?
    group by skills.name
    order by frequency desc;
    """
    return execute_query(sql, (industry_id,))

# %% nbs/db_ops.ipynb 35
def top_skills_by_category(category: str, country: Optional[str]=None, city:Optional[str]=None) -> list[tuple]:
    sql = """
    select skills.name, count(*) as frequency
    from job_skills 
    join skills on job_skills.skill_id = skills.id
    join jobs on job_skills.job_id = jobs.id
    join locations on jobs.location_id = locations.id
    where skills.category like ?

    """
    params = [f'%{category}%']
    if country:
        sql += ' and lower(locations.country) = lower(?)'
        params.append(country)
    if city:
        sql += ' and lower(locations.city) = lower(?)'
        params.append(city)
   
    sql += " group by skills.name order by frequency desc;" 
    return execute_query(sql, tuple(params))

# %% nbs/db_ops.ipynb 38
def skill_salary_range(skill_id: int) -> list[tuple]:
    sql = """
    select round(avg(salary_min), 0), round(avg(salary_max), 0)
    from jobs join job_skills on jobs.id = job_skills.job_id
    where skill_id = ?;
    """
    return execute_query(sql, (skill_id, ))

# %% nbs/db_ops.ipynb 41
def skills_ranked_by_salary(limit: Optional[int]=None) -> list[tuple]:
    """calculate the midpoint salary for each individual job first, then average those midpoints"""

    sql = """
    select skills.name, round(avg((jobs.salary_min + jobs.salary_max)/2), 0) as avg_salary
    from jobs join job_skills on jobs.id = job_skills.job_id
    join skills on job_skills.skill_id = skills.id
    group by job_skills.skill_id
    order by avg_salary desc
    """
    if limit:
        sql += " limit ?;"
        return execute_query(sql, (limit,))
    else:
        sql += ";"
        return execute_query(sql)

# %% nbs/db_ops.ipynb 44
def missing_skills(job: str,  existing: list[str], country: Optional[str]=None, city:Optional[str]=None) -> list[tuple]:
    required = [skill[0] for skill in skills_for_job(job, country, city)]
    return list(set(required) - set(existing))

# %% nbs/db_ops.ipynb 47
def companies_hiring_for_skill(skill_id: int) -> list[tuple]:
    sql = """
    select skills.name, companies.name, count(*) as job_count
    from jobs 
    join job_skills on jobs.id = job_skills.job_id
    join skills on skills.id = job_skills.skill_id
    join companies on jobs.company_id = companies.id
    where job_skills.skill_id = ?
    group by jobs.company_id, companies.name
    order by skills.name, job_count desc;
    """
    return execute_query(sql, (skill_id,))
